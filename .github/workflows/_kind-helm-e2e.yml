name: _kind-helm-e2e

on:
  workflow_call:
    inputs:
      ingress_port:
        type: string
        required: false
        default: "30000"
      namespace:
        type: string
        required: false
        default: "url-platform"
      release_name:
        type: string
        required: false
        default: "url-platform"
    secrets:
      POSTGRES_USER:
        required: true
      POSTGRES_PASSWORD:
        required: true

jobs:
  kind-helm-e2e:
    runs-on: ubuntu-latest
    timeout-minutes: 25
    env:
      NAMESPACE: ${{ inputs.namespace }}
      RELEASE_NAME: ${{ inputs.release_name }}
      INGRESS_PORT: ${{ inputs.ingress_port }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install kubectl
        uses: azure/setup-kubectl@v4

      - name: Install Helm
        uses: azure/setup-helm@v4

      - name: Create kind cluster
        uses: helm/kind-action@v1.10.0
        with:
          cluster_name: url-platform
          config: k8s/kind-config.yaml

      - name: Install ingress-nginx (kind provider)
        run: |
          kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/main/deploy/static/provider/kind/deploy.yaml
          kubectl -n ingress-nginx wait --for=condition=ready pod -l app.kubernetes.io/component=controller --timeout=180s

      - name: Build service images
        run: |
          docker build -t url-service:dev services/url-service
          docker build -t redirect-service:dev services/redirect-service
          docker build -t analytics-service:dev services/analytics-service

      - name: Pull third-party images
        run: |
          # Pre-pull Flyway image so kind doesn't attempt to pull it during
          # helm upgrade — the migration Job runs as a Helm hook and blocks
          # the deploy, so any image pull delay causes an apparent hang.
          docker pull flyway/flyway:12-alpine

      - name: Load images into kind
        run: |
          kind load docker-image url-service:dev --name url-platform
          kind load docker-image redirect-service:dev --name url-platform
          kind load docker-image analytics-service:dev --name url-platform
          kind load docker-image flyway/flyway:12-alpine --name url-platform

      - name: Create namespace
        run: |
          kubectl create namespace "$NAMESPACE"

      - name: Apply postgres secret
        env:
          POSTGRES_USER: ${{ secrets.POSTGRES_USER }}
          POSTGRES_PASSWORD: ${{ secrets.POSTGRES_PASSWORD }}
        run: |
          cat > /tmp/postgres-secret.yaml <<EOF
          apiVersion: v1
          kind: Secret
          metadata:
            name: postgres-secret
            namespace: ${NAMESPACE}
          type: Opaque
          stringData:
            POSTGRES_USER: "${POSTGRES_USER}"
            POSTGRES_PASSWORD: "${POSTGRES_PASSWORD}"
            DATABASE_URL: "postgresql://${POSTGRES_USER}:${POSTGRES_PASSWORD}@postgres:5432/url_platform"
          EOF
          kubectl apply -f /tmp/postgres-secret.yaml

      - name: Deploy via Helm
        run: |
          helm lint charts/url-platform
          helm upgrade --install "$RELEASE_NAME" charts/url-platform -n "$NAMESPACE" -f charts/url-platform/values-kind-e2e.yaml

      - name: Wait for workloads
        run: |
          kubectl -n "$NAMESPACE" rollout status deploy/postgres --timeout=180s
          kubectl -n "$NAMESPACE" rollout status deploy/url-service --timeout=180s
          kubectl -n "$NAMESPACE" rollout status deploy/redirect-service --timeout=180s
          kubectl -n "$NAMESPACE" rollout status deploy/analytics-service --timeout=180s
          kubectl -n "$NAMESPACE" get pods -o wide
          kubectl -n "$NAMESPACE" get ingress

      - name: Smoke test through ingress
        run: |
          set -Eeuo pipefail
          trap 'echo "❌ failed at line $LINENO: $BASH_COMMAND"' ERR

          base="http://localhost:${INGRESS_PORT}"

          echo "Waiting for ingress to become ready..."
          for i in $(seq 1 30); do
            http_code="$(curl -sS --max-time 5 -o /dev/null -w "%{http_code}" "${base}/health" || true)"
            if [[ "$http_code" == "200" ]]; then
              echo "Ingress ready after $i attempts (HTTP $http_code)"
              break
            fi
            echo "Attempt $i: HTTP $http_code, retrying in 2s..."
            sleep 2
          done

          # hard fail if still not ready
          curl -fsS --max-time 5 "${base}/health" >/dev/null

          # create URL
          resp="$(curl -fsS -X POST "${base}/urls" -H 'content-type: application/json' -d '{"long_url":"https://example.com"}')"
          echo "$resp"
          code="$(printf '%s' "$resp" | python3 -c 'import json,sys; print(json.load(sys.stdin)["code"])')"
          echo "code=$code"

          # redirect should 302 to example.com
          loc="$(curl -sSI "${base}/r/${code}" | awk -F': ' 'tolower($1)=="location"{print $2}' | tr -d '\r')"
          echo "location=$loc"
          test "$loc" = "https://example.com"

          # hit redirect a couple times
          curl -fsS -o /dev/null "${base}/r/${code}"
          curl -fsS -o /dev/null "${base}/r/${code}"

          # stats should exist and count >= 1
          stats="$(curl -fsS "${base}/stats/${code}")"
          printf '%s' "$stats" | python3 -c 'import json,sys; d=json.load(sys.stdin); assert d["count"] >= 1'

      - name: Debug (on failure)
        if: failure()
        run: |
          echo "==== pods ===="
          kubectl -n "$NAMESPACE" get pods -o wide || true
          echo "==== ingress ===="
          kubectl -n "$NAMESPACE" describe ingress url-platform || true
          echo "==== url-service logs ===="
          kubectl -n "$NAMESPACE" logs deploy/url-service --tail=200 || true
          echo "==== redirect-service logs ===="
          kubectl -n "$NAMESPACE" logs deploy/redirect-service --tail=200 || true
          echo "==== analytics-service logs ===="
          kubectl -n "$NAMESPACE" logs deploy/analytics-service --tail=200 || true
          echo "==== postgres logs ===="
          kubectl -n "$NAMESPACE" logs deploy/postgres --tail=200 || true
          echo "==== endpoints ===="
          kubectl -n "$NAMESPACE" get endpoints || true
          echo "==== ingress-nginx controller svc ===="
          kubectl -n ingress-nginx get svc ingress-nginx-controller -o wide || true
          echo "==== ingress-nginx controller logs ===="
          kubectl -n ingress-nginx logs deploy/ingress-nginx-controller --tail=200 || true
          echo "==== helm status ===="
          helm -n "$NAMESPACE" status "$RELEASE_NAME" || true
          echo "==== helm manifest (tail) ===="
          helm -n "$NAMESPACE" get manifest "$RELEASE_NAME" | tail -n 200 || true
      - name: Save k8s debug artifacts
        if: failure()
        run: |
          mkdir -p artifacts
          kubectl -n "$NAMESPACE" get all -o wide > artifacts/get-all.txt || true
          kubectl -n "$NAMESPACE" describe ingress url-platform > artifacts/ingress.txt || true
          kubectl -n "$NAMESPACE" get endpoints > artifacts/endpoints.txt || true
          kubectl -n ingress-nginx logs deploy/ingress-nginx-controller --tail=500 > artifacts/ingress-nginx.log || true
          helm -n "$NAMESPACE" status "$RELEASE_NAME" > artifacts/helm-status.txt || true

      - name: Upload k8s debug artifacts
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: kind-helm-e2e-debug
          path: artifacts/
          if-no-files-found: error
